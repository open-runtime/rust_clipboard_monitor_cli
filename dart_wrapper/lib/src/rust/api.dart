// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `convert_to_dart_event`, `create_and_run_app_switcher_unsafe`, `create_and_run_app_switcher`, `ensure_nsapp_initialized`, `execute_on_main_thread`, `extract_accessibility_context_safe`, `extract_app_info_from_notification`, `get_browser_context`, `get_comprehensive_clipboard_data_internal`, `get_comprehensive_clipboard_data`, `get_current_frontmost_app`, `get_format_emoji`, `get_monitor_state`, `get_system_context`, `get_window_context_for_app`, `init_monitor_state`, `monitor_clipboard_changes`, `new`, `run_app_switcher_service`, `safe_truncate`, `setup_basic_app_detection`, `setup_hybrid_detection_system`, `setup_real_notification_system`, `setup_simple_workspace_monitor`, `setup_workspace_monitoring_on_background_thread`, `test_clipboard_monitoring`, `test_nsworkspace_access`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `InternalStreamListener`, `MonitorState`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseOwnerTyShouldIgnore): `on_app_switch`

/// Start monitoring app switches and return a stream of events
/// This provides real-time app switching notifications through a Stream
Stream<DartAppSwitchEventData> monitorAppSwitches(
        {required bool enhanced,
        required int verbose,
        required bool background}) =>
    RustLib.instance.api.crateApiMonitorAppSwitches(
        enhanced: enhanced, verbose: verbose, background: background);

/// Stop monitoring app switches
Future<void> stopMonitoring() => RustLib.instance.api.crateApiStopMonitoring();

/// Check if currently monitoring
Future<bool> isMonitoring() => RustLib.instance.api.crateApiIsMonitoring();

/// Check accessibility permissions
Future<bool> checkAccessibilityPermissions() =>
    RustLib.instance.api.crateApiCheckAccessibilityPermissions();

/// Test comprehensive clipboard monitoring capabilities
Future<void> testComprehensiveClipboardMonitoring() =>
    RustLib.instance.api.crateApiTestComprehensiveClipboardMonitoring();

/// Get current clipboard data (one-time query)
Future<DartClipboardData?> getCurrentClipboardInfo() =>
    RustLib.instance.api.crateApiGetCurrentClipboardInfo();

/// Get current clipboard data silently (no debug output)
Future<DartClipboardData?> getCurrentClipboardInfoSilent() =>
    RustLib.instance.api.crateApiGetCurrentClipboardInfoSilent();

/// Simple one-time query for current app without streaming
Future<DartAppInfo?> getCurrentAppInfo() =>
    RustLib.instance.api.crateApiGetCurrentAppInfo();

/// Accessibility context data
class AccessibilityContextData {
  final String? focusedElementRole;
  final String? focusedElementTitle;
  final String? selectedText;
  final String? documentPath;

  const AccessibilityContextData({
    this.focusedElementRole,
    this.focusedElementTitle,
    this.selectedText,
    this.documentPath,
  });

  @override
  int get hashCode =>
      focusedElementRole.hashCode ^
      focusedElementTitle.hashCode ^
      selectedText.hashCode ^
      documentPath.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AccessibilityContextData &&
          runtimeType == other.runtimeType &&
          focusedElementRole == other.focusedElementRole &&
          focusedElementTitle == other.focusedElementTitle &&
          selectedText == other.selectedText &&
          documentPath == other.documentPath;
}

/// Browser-specific context
class BrowserContext {
  final String? currentUrl;
  final String? pageTitle;
  final BigInt? tabCount;
  final bool isIncognito;

  const BrowserContext({
    this.currentUrl,
    this.pageTitle,
    this.tabCount,
    required this.isIncognito,
  });

  @override
  int get hashCode =>
      currentUrl.hashCode ^
      pageTitle.hashCode ^
      tabCount.hashCode ^
      isIncognito.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BrowserContext &&
          runtimeType == other.runtimeType &&
          currentUrl == other.currentUrl &&
          pageTitle == other.pageTitle &&
          tabCount == other.tabCount &&
          isIncognito == other.isIncognito;
}

/// Window bounds information for clipboard context
class ClipboardWindowBounds {
  final double x;
  final double y;
  final double width;
  final double height;

  const ClipboardWindowBounds({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode =>
      x.hashCode ^ y.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ClipboardWindowBounds &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          width == other.width &&
          height == other.height;
}

/// App information for Dart
class DartAppInfo {
  final String name;
  final String bundleId;
  final int pid;
  final String? path;

  const DartAppInfo({
    required this.name,
    required this.bundleId,
    required this.pid,
    this.path,
  });

  @override
  int get hashCode =>
      name.hashCode ^ bundleId.hashCode ^ pid.hashCode ^ path.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartAppInfo &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          bundleId == other.bundleId &&
          pid == other.pid &&
          path == other.path;
}

/// App switch event for Dart
class DartAppSwitchEventData {
  final DartAppInfo appInfo;
  final DartAppInfo? previousApp;
  final String eventType;
  final String? windowTitle;
  final String? url;

  const DartAppSwitchEventData({
    required this.appInfo,
    this.previousApp,
    required this.eventType,
    this.windowTitle,
    this.url,
  });

  @override
  int get hashCode =>
      appInfo.hashCode ^
      previousApp.hashCode ^
      eventType.hashCode ^
      windowTitle.hashCode ^
      url.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartAppSwitchEventData &&
          runtimeType == other.runtimeType &&
          appInfo == other.appInfo &&
          previousApp == other.previousApp &&
          eventType == other.eventType &&
          windowTitle == other.windowTitle &&
          url == other.url;
}

/// Enhanced clipboard data with full context for Dart
class DartClipboardData {
  final PlatformInt64 changeCount;
  final String timestamp;
  final DartAppInfo? sourceApp;
  final List<DartClipboardFormat> formats;
  final String primaryContent;
  final WindowContext? windowContext;
  final BrowserContext? browserContext;
  final SpaceContext? spaceContext;
  final AccessibilityContextData? accessibilityContext;
  final SystemContext systemContext;

  const DartClipboardData({
    required this.changeCount,
    required this.timestamp,
    this.sourceApp,
    required this.formats,
    required this.primaryContent,
    this.windowContext,
    this.browserContext,
    this.spaceContext,
    this.accessibilityContext,
    required this.systemContext,
  });

  @override
  int get hashCode =>
      changeCount.hashCode ^
      timestamp.hashCode ^
      sourceApp.hashCode ^
      formats.hashCode ^
      primaryContent.hashCode ^
      windowContext.hashCode ^
      browserContext.hashCode ^
      spaceContext.hashCode ^
      accessibilityContext.hashCode ^
      systemContext.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartClipboardData &&
          runtimeType == other.runtimeType &&
          changeCount == other.changeCount &&
          timestamp == other.timestamp &&
          sourceApp == other.sourceApp &&
          formats == other.formats &&
          primaryContent == other.primaryContent &&
          windowContext == other.windowContext &&
          browserContext == other.browserContext &&
          spaceContext == other.spaceContext &&
          accessibilityContext == other.accessibilityContext &&
          systemContext == other.systemContext;
}

/// Individual clipboard format with data
class DartClipboardFormat {
  final String formatType;
  final BigInt dataSize;
  final String contentPreview;
  final bool isAvailable;

  const DartClipboardFormat({
    required this.formatType,
    required this.dataSize,
    required this.contentPreview,
    required this.isAvailable,
  });

  @override
  int get hashCode =>
      formatType.hashCode ^
      dataSize.hashCode ^
      contentPreview.hashCode ^
      isAvailable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartClipboardFormat &&
          runtimeType == other.runtimeType &&
          formatType == other.formatType &&
          dataSize == other.dataSize &&
          contentPreview == other.contentPreview &&
          isAvailable == other.isAvailable;
}

/// Space/Desktop context
class SpaceContext {
  final int spaceIndex;
  final String spaceName;
  final String displayUuid;

  const SpaceContext({
    required this.spaceIndex,
    required this.spaceName,
    required this.displayUuid,
  });

  @override
  int get hashCode =>
      spaceIndex.hashCode ^ spaceName.hashCode ^ displayUuid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpaceContext &&
          runtimeType == other.runtimeType &&
          spaceIndex == other.spaceIndex &&
          spaceName == other.spaceName &&
          displayUuid == other.displayUuid;
}

/// System context information
class SystemContext {
  final int displayCount;
  final int activeDisplayId;
  final bool sessionActive;
  final bool screenLocked;

  const SystemContext({
    required this.displayCount,
    required this.activeDisplayId,
    required this.sessionActive,
    required this.screenLocked,
  });

  @override
  int get hashCode =>
      displayCount.hashCode ^
      activeDisplayId.hashCode ^
      sessionActive.hashCode ^
      screenLocked.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SystemContext &&
          runtimeType == other.runtimeType &&
          displayCount == other.displayCount &&
          activeDisplayId == other.activeDisplayId &&
          sessionActive == other.sessionActive &&
          screenLocked == other.screenLocked;
}

/// Window context information
class WindowContext {
  final String? windowTitle;
  final int windowId;
  final int windowLayer;
  final bool isFullscreen;
  final bool isMinimized;
  final ClipboardWindowBounds? bounds;

  const WindowContext({
    this.windowTitle,
    required this.windowId,
    required this.windowLayer,
    required this.isFullscreen,
    required this.isMinimized,
    this.bounds,
  });

  @override
  int get hashCode =>
      windowTitle.hashCode ^
      windowId.hashCode ^
      windowLayer.hashCode ^
      isFullscreen.hashCode ^
      isMinimized.hashCode ^
      bounds.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WindowContext &&
          runtimeType == other.runtimeType &&
          windowTitle == other.windowTitle &&
          windowId == other.windowId &&
          windowLayer == other.windowLayer &&
          isFullscreen == other.isFullscreen &&
          isMinimized == other.isMinimized &&
          bounds == other.bounds;
}
